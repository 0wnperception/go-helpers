package tests

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i local_agent/pkg/repo.PersistentIface -o ./tests/persistent_iface_mock.go -n PersistentIfaceMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// PersistentIfaceMock implements repo.PersistentIface
type PersistentIfaceMock[T any] struct {
	t minimock.Tester

	funcDelete          func(ctx context.Context, ID string) (err error)
	inspectFuncDelete   func(ctx context.Context, ID string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mPersistentIfaceMockDelete[T]

	funcFlush          func(ctx context.Context)
	inspectFuncFlush   func(ctx context.Context)
	afterFlushCounter  uint64
	beforeFlushCounter uint64
	FlushMock          mPersistentIfaceMockFlush[T]

	funcGetActive          func(ctx context.Context) (p1 []*T, err error)
	inspectFuncGetActive   func(ctx context.Context)
	afterGetActiveCounter  uint64
	beforeGetActiveCounter uint64
	GetActiveMock          mPersistentIfaceMockGetActive[T]

	funcGetHistory          func(ctx context.Context) (p1 []*T, err error)
	inspectFuncGetHistory   func(ctx context.Context)
	afterGetHistoryCounter  uint64
	beforeGetHistoryCounter uint64
	GetHistoryMock          mPersistentIfaceMockGetHistory[T]

	funcIsExist          func(ctx context.Context, ID string) (b1 bool)
	inspectFuncIsExist   func(ctx context.Context, ID string)
	afterIsExistCounter  uint64
	beforeIsExistCounter uint64
	IsExistMock          mPersistentIfaceMockIsExist[T]

	funcStore          func(ctx context.Context, ID string, e *T) (err error)
	inspectFuncStore   func(ctx context.Context, ID string, e *T)
	afterStoreCounter  uint64
	beforeStoreCounter uint64
	StoreMock          mPersistentIfaceMockStore[T]

	funcStoreTable          func(ctx context.Context, emap map[string]*T) (err error)
	inspectFuncStoreTable   func(ctx context.Context, emap map[string]*T)
	afterStoreTableCounter  uint64
	beforeStoreTableCounter uint64
	StoreTableMock          mPersistentIfaceMockStoreTable[T]
}

// NewPersistentIfaceMock returns a mock for repo.PersistentIface
func NewPersistentIfaceMock[T any](t minimock.Tester) *PersistentIfaceMock[T] {
	m := &PersistentIfaceMock[T]{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteMock = mPersistentIfaceMockDelete[T]{mock: m}
	m.DeleteMock.callArgs = []*PersistentIfaceMockDeleteParams{}

	m.FlushMock = mPersistentIfaceMockFlush[T]{mock: m}
	m.FlushMock.callArgs = []*PersistentIfaceMockFlushParams{}

	m.GetActiveMock = mPersistentIfaceMockGetActive[T]{mock: m}
	m.GetActiveMock.callArgs = []*PersistentIfaceMockGetActiveParams{}

	m.GetHistoryMock = mPersistentIfaceMockGetHistory[T]{mock: m}
	m.GetHistoryMock.callArgs = []*PersistentIfaceMockGetHistoryParams{}

	m.IsExistMock = mPersistentIfaceMockIsExist[T]{mock: m}
	m.IsExistMock.callArgs = []*PersistentIfaceMockIsExistParams{}

	m.StoreMock = mPersistentIfaceMockStore[T]{mock: m}
	m.StoreMock.callArgs = []*PersistentIfaceMockStoreParams{}

	m.StoreTableMock = mPersistentIfaceMockStoreTable[T]{mock: m}
	m.StoreTableMock.callArgs = []*PersistentIfaceMockStoreTableParams[T]{}

	return m
}

type mPersistentIfaceMockDelete[T any] struct {
	mock               *PersistentIfaceMock[T]
	defaultExpectation *PersistentIfaceMockDeleteExpectation[T]
	expectations       []*PersistentIfaceMockDeleteExpectation[T]

	callArgs []*PersistentIfaceMockDeleteParams
	mutex    sync.RWMutex
}

// PersistentIfaceMockDeleteExpectation specifies expectation struct of the PersistentIface.Delete
type PersistentIfaceMockDeleteExpectation[T any] struct {
	mock    *PersistentIfaceMock[T]
	params  *PersistentIfaceMockDeleteParams
	results *PersistentIfaceMockDeleteResults
	Counter uint64
}

// PersistentIfaceMockDeleteParams contains parameters of the PersistentIface.Delete
type PersistentIfaceMockDeleteParams struct {
	ctx context.Context
	ID  string
}

// PersistentIfaceMockDeleteResults contains results of the PersistentIface.Delete
type PersistentIfaceMockDeleteResults struct {
	err error
}

// Expect sets up expected params for PersistentIface.Delete
func (mmDelete *mPersistentIfaceMockDelete[T]) Expect(ctx context.Context, ID string) *mPersistentIfaceMockDelete[T] {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PersistentIfaceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PersistentIfaceMockDeleteExpectation[T]{}
	}

	mmDelete.defaultExpectation.params = &PersistentIfaceMockDeleteParams{ctx, ID}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the PersistentIface.Delete
func (mmDelete *mPersistentIfaceMockDelete[T]) Inspect(f func(ctx context.Context, ID string)) *mPersistentIfaceMockDelete[T] {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for PersistentIfaceMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by PersistentIface.Delete
func (mmDelete *mPersistentIfaceMockDelete[T]) Return(err error) *PersistentIfaceMock[T] {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PersistentIfaceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PersistentIfaceMockDeleteExpectation[T]{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &PersistentIfaceMockDeleteResults{err}
	return mmDelete.mock
}

//Set uses given function f to mock the PersistentIface.Delete method
func (mmDelete *mPersistentIfaceMockDelete[T]) Set(f func(ctx context.Context, ID string) (err error)) *PersistentIfaceMock[T] {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the PersistentIface.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the PersistentIface.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the PersistentIface.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mPersistentIfaceMockDelete[T]) When(ctx context.Context, ID string) *PersistentIfaceMockDeleteExpectation[T] {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PersistentIfaceMock.Delete mock is already set by Set")
	}

	expectation := &PersistentIfaceMockDeleteExpectation[T]{
		mock:   mmDelete.mock,
		params: &PersistentIfaceMockDeleteParams{ctx, ID},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up PersistentIface.Delete return parameters for the expectation previously defined by the When method
func (e *PersistentIfaceMockDeleteExpectation[T]) Then(err error) *PersistentIfaceMock[T] {
	e.results = &PersistentIfaceMockDeleteResults{err}
	return e.mock
}

// Delete implements repo.PersistentIface
func (mmDelete *PersistentIfaceMock[T]) Delete(ctx context.Context, ID string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, ID)
	}

	mm_params := &PersistentIfaceMockDeleteParams{ctx, ID}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := PersistentIfaceMockDeleteParams{ctx, ID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("PersistentIfaceMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the PersistentIfaceMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, ID)
	}
	mmDelete.t.Fatalf("Unexpected call to PersistentIfaceMock.Delete. %v %v", ctx, ID)
	return
}

// DeleteAfterCounter returns a count of finished PersistentIfaceMock.Delete invocations
func (mmDelete *PersistentIfaceMock[T]) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of PersistentIfaceMock.Delete invocations
func (mmDelete *PersistentIfaceMock[T]) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to PersistentIfaceMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mPersistentIfaceMockDelete[T]) Calls() []*PersistentIfaceMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*PersistentIfaceMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *PersistentIfaceMock[T]) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *PersistentIfaceMock[T]) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersistentIfaceMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PersistentIfaceMock.Delete")
		} else {
			m.t.Errorf("Expected call to PersistentIfaceMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to PersistentIfaceMock.Delete")
	}
}

type mPersistentIfaceMockFlush[T any] struct {
	mock               *PersistentIfaceMock[T]
	defaultExpectation *PersistentIfaceMockFlushExpectation[T]
	expectations       []*PersistentIfaceMockFlushExpectation[T]

	callArgs []*PersistentIfaceMockFlushParams
	mutex    sync.RWMutex
}

// PersistentIfaceMockFlushExpectation specifies expectation struct of the PersistentIface.Flush
type PersistentIfaceMockFlushExpectation[T any] struct {
	mock   *PersistentIfaceMock[T]
	params *PersistentIfaceMockFlushParams

	Counter uint64
}

// PersistentIfaceMockFlushParams contains parameters of the PersistentIface.Flush
type PersistentIfaceMockFlushParams struct {
	ctx context.Context
}

// Expect sets up expected params for PersistentIface.Flush
func (mmFlush *mPersistentIfaceMockFlush[T]) Expect(ctx context.Context) *mPersistentIfaceMockFlush[T] {
	if mmFlush.mock.funcFlush != nil {
		mmFlush.mock.t.Fatalf("PersistentIfaceMock.Flush mock is already set by Set")
	}

	if mmFlush.defaultExpectation == nil {
		mmFlush.defaultExpectation = &PersistentIfaceMockFlushExpectation[T]{}
	}

	mmFlush.defaultExpectation.params = &PersistentIfaceMockFlushParams{ctx}
	for _, e := range mmFlush.expectations {
		if minimock.Equal(e.params, mmFlush.defaultExpectation.params) {
			mmFlush.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFlush.defaultExpectation.params)
		}
	}

	return mmFlush
}

// Inspect accepts an inspector function that has same arguments as the PersistentIface.Flush
func (mmFlush *mPersistentIfaceMockFlush[T]) Inspect(f func(ctx context.Context)) *mPersistentIfaceMockFlush[T] {
	if mmFlush.mock.inspectFuncFlush != nil {
		mmFlush.mock.t.Fatalf("Inspect function is already set for PersistentIfaceMock.Flush")
	}

	mmFlush.mock.inspectFuncFlush = f

	return mmFlush
}

// Return sets up results that will be returned by PersistentIface.Flush
func (mmFlush *mPersistentIfaceMockFlush[T]) Return() *PersistentIfaceMock[T] {
	if mmFlush.mock.funcFlush != nil {
		mmFlush.mock.t.Fatalf("PersistentIfaceMock.Flush mock is already set by Set")
	}

	if mmFlush.defaultExpectation == nil {
		mmFlush.defaultExpectation = &PersistentIfaceMockFlushExpectation[T]{mock: mmFlush.mock}
	}

	return mmFlush.mock
}

//Set uses given function f to mock the PersistentIface.Flush method
func (mmFlush *mPersistentIfaceMockFlush[T]) Set(f func(ctx context.Context)) *PersistentIfaceMock[T] {
	if mmFlush.defaultExpectation != nil {
		mmFlush.mock.t.Fatalf("Default expectation is already set for the PersistentIface.Flush method")
	}

	if len(mmFlush.expectations) > 0 {
		mmFlush.mock.t.Fatalf("Some expectations are already set for the PersistentIface.Flush method")
	}

	mmFlush.mock.funcFlush = f
	return mmFlush.mock
}

// Flush implements repo.PersistentIface
func (mmFlush *PersistentIfaceMock[T]) Flush(ctx context.Context) {
	mm_atomic.AddUint64(&mmFlush.beforeFlushCounter, 1)
	defer mm_atomic.AddUint64(&mmFlush.afterFlushCounter, 1)

	if mmFlush.inspectFuncFlush != nil {
		mmFlush.inspectFuncFlush(ctx)
	}

	mm_params := &PersistentIfaceMockFlushParams{ctx}

	// Record call args
	mmFlush.FlushMock.mutex.Lock()
	mmFlush.FlushMock.callArgs = append(mmFlush.FlushMock.callArgs, mm_params)
	mmFlush.FlushMock.mutex.Unlock()

	for _, e := range mmFlush.FlushMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFlush.FlushMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFlush.FlushMock.defaultExpectation.Counter, 1)
		mm_want := mmFlush.FlushMock.defaultExpectation.params
		mm_got := PersistentIfaceMockFlushParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFlush.t.Errorf("PersistentIfaceMock.Flush got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmFlush.funcFlush != nil {
		mmFlush.funcFlush(ctx)
		return
	}
	mmFlush.t.Fatalf("Unexpected call to PersistentIfaceMock.Flush. %v", ctx)

}

// FlushAfterCounter returns a count of finished PersistentIfaceMock.Flush invocations
func (mmFlush *PersistentIfaceMock[T]) FlushAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlush.afterFlushCounter)
}

// FlushBeforeCounter returns a count of PersistentIfaceMock.Flush invocations
func (mmFlush *PersistentIfaceMock[T]) FlushBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlush.beforeFlushCounter)
}

// Calls returns a list of arguments used in each call to PersistentIfaceMock.Flush.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFlush *mPersistentIfaceMockFlush[T]) Calls() []*PersistentIfaceMockFlushParams {
	mmFlush.mutex.RLock()

	argCopy := make([]*PersistentIfaceMockFlushParams, len(mmFlush.callArgs))
	copy(argCopy, mmFlush.callArgs)

	mmFlush.mutex.RUnlock()

	return argCopy
}

// MinimockFlushDone returns true if the count of the Flush invocations corresponds
// the number of defined expectations
func (m *PersistentIfaceMock[T]) MinimockFlushDone() bool {
	for _, e := range m.FlushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FlushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFlushCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlush != nil && mm_atomic.LoadUint64(&m.afterFlushCounter) < 1 {
		return false
	}
	return true
}

// MinimockFlushInspect logs each unmet expectation
func (m *PersistentIfaceMock[T]) MinimockFlushInspect() {
	for _, e := range m.FlushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersistentIfaceMock.Flush with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FlushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFlushCounter) < 1 {
		if m.FlushMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PersistentIfaceMock.Flush")
		} else {
			m.t.Errorf("Expected call to PersistentIfaceMock.Flush with params: %#v", *m.FlushMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlush != nil && mm_atomic.LoadUint64(&m.afterFlushCounter) < 1 {
		m.t.Error("Expected call to PersistentIfaceMock.Flush")
	}
}

type mPersistentIfaceMockGetActive[T any] struct {
	mock               *PersistentIfaceMock[T]
	defaultExpectation *PersistentIfaceMockGetActiveExpectation[T]
	expectations       []*PersistentIfaceMockGetActiveExpectation[T]

	callArgs []*PersistentIfaceMockGetActiveParams
	mutex    sync.RWMutex
}

// PersistentIfaceMockGetActiveExpectation specifies expectation struct of the PersistentIface.GetActive
type PersistentIfaceMockGetActiveExpectation[T any] struct {
	mock    *PersistentIfaceMock[T]
	params  *PersistentIfaceMockGetActiveParams
	results *PersistentIfaceMockGetActiveResults[T]
	Counter uint64
}

// PersistentIfaceMockGetActiveParams contains parameters of the PersistentIface.GetActive
type PersistentIfaceMockGetActiveParams struct {
	ctx context.Context
}

// PersistentIfaceMockGetActiveResults contains results of the PersistentIface.GetActive
type PersistentIfaceMockGetActiveResults[T any] struct {
	p1  []*T
	err error
}

// Expect sets up expected params for PersistentIface.GetActive
func (mmGetActive *mPersistentIfaceMockGetActive[T]) Expect(ctx context.Context) *mPersistentIfaceMockGetActive[T] {
	if mmGetActive.mock.funcGetActive != nil {
		mmGetActive.mock.t.Fatalf("PersistentIfaceMock.GetActive mock is already set by Set")
	}

	if mmGetActive.defaultExpectation == nil {
		mmGetActive.defaultExpectation = &PersistentIfaceMockGetActiveExpectation[T]{}
	}

	mmGetActive.defaultExpectation.params = &PersistentIfaceMockGetActiveParams{ctx}
	for _, e := range mmGetActive.expectations {
		if minimock.Equal(e.params, mmGetActive.defaultExpectation.params) {
			mmGetActive.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetActive.defaultExpectation.params)
		}
	}

	return mmGetActive
}

// Inspect accepts an inspector function that has same arguments as the PersistentIface.GetActive
func (mmGetActive *mPersistentIfaceMockGetActive[T]) Inspect(f func(ctx context.Context)) *mPersistentIfaceMockGetActive[T] {
	if mmGetActive.mock.inspectFuncGetActive != nil {
		mmGetActive.mock.t.Fatalf("Inspect function is already set for PersistentIfaceMock.GetActive")
	}

	mmGetActive.mock.inspectFuncGetActive = f

	return mmGetActive
}

// Return sets up results that will be returned by PersistentIface.GetActive
func (mmGetActive *mPersistentIfaceMockGetActive[T]) Return(p1 []*T, err error) *PersistentIfaceMock[T] {
	if mmGetActive.mock.funcGetActive != nil {
		mmGetActive.mock.t.Fatalf("PersistentIfaceMock.GetActive mock is already set by Set")
	}

	if mmGetActive.defaultExpectation == nil {
		mmGetActive.defaultExpectation = &PersistentIfaceMockGetActiveExpectation[T]{mock: mmGetActive.mock}
	}
	mmGetActive.defaultExpectation.results = &PersistentIfaceMockGetActiveResults[T]{p1, err}
	return mmGetActive.mock
}

//Set uses given function f to mock the PersistentIface.GetActive method
func (mmGetActive *mPersistentIfaceMockGetActive[T]) Set(f func(ctx context.Context) (p1 []*T, err error)) *PersistentIfaceMock[T] {
	if mmGetActive.defaultExpectation != nil {
		mmGetActive.mock.t.Fatalf("Default expectation is already set for the PersistentIface.GetActive method")
	}

	if len(mmGetActive.expectations) > 0 {
		mmGetActive.mock.t.Fatalf("Some expectations are already set for the PersistentIface.GetActive method")
	}

	mmGetActive.mock.funcGetActive = f
	return mmGetActive.mock
}

// When sets expectation for the PersistentIface.GetActive which will trigger the result defined by the following
// Then helper
func (mmGetActive *mPersistentIfaceMockGetActive[T]) When(ctx context.Context) *PersistentIfaceMockGetActiveExpectation[T] {
	if mmGetActive.mock.funcGetActive != nil {
		mmGetActive.mock.t.Fatalf("PersistentIfaceMock.GetActive mock is already set by Set")
	}

	expectation := &PersistentIfaceMockGetActiveExpectation[T]{
		mock:   mmGetActive.mock,
		params: &PersistentIfaceMockGetActiveParams{ctx},
	}
	mmGetActive.expectations = append(mmGetActive.expectations, expectation)
	return expectation
}

// Then sets up PersistentIface.GetActive return parameters for the expectation previously defined by the When method
func (e *PersistentIfaceMockGetActiveExpectation[T]) Then(p1 []*T, err error) *PersistentIfaceMock[T] {
	e.results = &PersistentIfaceMockGetActiveResults[T]{p1, err}
	return e.mock
}

// GetActive implements repo.PersistentIface
func (mmGetActive *PersistentIfaceMock[T]) GetActive(ctx context.Context) (p1 []*T, err error) {
	mm_atomic.AddUint64(&mmGetActive.beforeGetActiveCounter, 1)
	defer mm_atomic.AddUint64(&mmGetActive.afterGetActiveCounter, 1)

	if mmGetActive.inspectFuncGetActive != nil {
		mmGetActive.inspectFuncGetActive(ctx)
	}

	mm_params := &PersistentIfaceMockGetActiveParams{ctx}

	// Record call args
	mmGetActive.GetActiveMock.mutex.Lock()
	mmGetActive.GetActiveMock.callArgs = append(mmGetActive.GetActiveMock.callArgs, mm_params)
	mmGetActive.GetActiveMock.mutex.Unlock()

	for _, e := range mmGetActive.GetActiveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetActive.GetActiveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetActive.GetActiveMock.defaultExpectation.Counter, 1)
		mm_want := mmGetActive.GetActiveMock.defaultExpectation.params
		mm_got := PersistentIfaceMockGetActiveParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetActive.t.Errorf("PersistentIfaceMock.GetActive got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetActive.GetActiveMock.defaultExpectation.results
		if mm_results == nil {
			mmGetActive.t.Fatal("No results are set for the PersistentIfaceMock.GetActive")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGetActive.funcGetActive != nil {
		return mmGetActive.funcGetActive(ctx)
	}
	mmGetActive.t.Fatalf("Unexpected call to PersistentIfaceMock.GetActive. %v", ctx)
	return
}

// GetActiveAfterCounter returns a count of finished PersistentIfaceMock.GetActive invocations
func (mmGetActive *PersistentIfaceMock[T]) GetActiveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActive.afterGetActiveCounter)
}

// GetActiveBeforeCounter returns a count of PersistentIfaceMock.GetActive invocations
func (mmGetActive *PersistentIfaceMock[T]) GetActiveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActive.beforeGetActiveCounter)
}

// Calls returns a list of arguments used in each call to PersistentIfaceMock.GetActive.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetActive *mPersistentIfaceMockGetActive[T]) Calls() []*PersistentIfaceMockGetActiveParams {
	mmGetActive.mutex.RLock()

	argCopy := make([]*PersistentIfaceMockGetActiveParams, len(mmGetActive.callArgs))
	copy(argCopy, mmGetActive.callArgs)

	mmGetActive.mutex.RUnlock()

	return argCopy
}

// MinimockGetActiveDone returns true if the count of the GetActive invocations corresponds
// the number of defined expectations
func (m *PersistentIfaceMock[T]) MinimockGetActiveDone() bool {
	for _, e := range m.GetActiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActive != nil && mm_atomic.LoadUint64(&m.afterGetActiveCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetActiveInspect logs each unmet expectation
func (m *PersistentIfaceMock[T]) MinimockGetActiveInspect() {
	for _, e := range m.GetActiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersistentIfaceMock.GetActive with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveCounter) < 1 {
		if m.GetActiveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PersistentIfaceMock.GetActive")
		} else {
			m.t.Errorf("Expected call to PersistentIfaceMock.GetActive with params: %#v", *m.GetActiveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActive != nil && mm_atomic.LoadUint64(&m.afterGetActiveCounter) < 1 {
		m.t.Error("Expected call to PersistentIfaceMock.GetActive")
	}
}

type mPersistentIfaceMockGetHistory[T any] struct {
	mock               *PersistentIfaceMock[T]
	defaultExpectation *PersistentIfaceMockGetHistoryExpectation[T]
	expectations       []*PersistentIfaceMockGetHistoryExpectation[T]

	callArgs []*PersistentIfaceMockGetHistoryParams
	mutex    sync.RWMutex
}

// PersistentIfaceMockGetHistoryExpectation specifies expectation struct of the PersistentIface.GetHistory
type PersistentIfaceMockGetHistoryExpectation[T any] struct {
	mock    *PersistentIfaceMock[T]
	params  *PersistentIfaceMockGetHistoryParams
	results *PersistentIfaceMockGetHistoryResults[T]
	Counter uint64
}

// PersistentIfaceMockGetHistoryParams contains parameters of the PersistentIface.GetHistory
type PersistentIfaceMockGetHistoryParams struct {
	ctx context.Context
}

// PersistentIfaceMockGetHistoryResults contains results of the PersistentIface.GetHistory
type PersistentIfaceMockGetHistoryResults[T any] struct {
	p1  []*T
	err error
}

// Expect sets up expected params for PersistentIface.GetHistory
func (mmGetHistory *mPersistentIfaceMockGetHistory[T]) Expect(ctx context.Context) *mPersistentIfaceMockGetHistory[T] {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("PersistentIfaceMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &PersistentIfaceMockGetHistoryExpectation[T]{}
	}

	mmGetHistory.defaultExpectation.params = &PersistentIfaceMockGetHistoryParams{ctx}
	for _, e := range mmGetHistory.expectations {
		if minimock.Equal(e.params, mmGetHistory.defaultExpectation.params) {
			mmGetHistory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetHistory.defaultExpectation.params)
		}
	}

	return mmGetHistory
}

// Inspect accepts an inspector function that has same arguments as the PersistentIface.GetHistory
func (mmGetHistory *mPersistentIfaceMockGetHistory[T]) Inspect(f func(ctx context.Context)) *mPersistentIfaceMockGetHistory[T] {
	if mmGetHistory.mock.inspectFuncGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("Inspect function is already set for PersistentIfaceMock.GetHistory")
	}

	mmGetHistory.mock.inspectFuncGetHistory = f

	return mmGetHistory
}

// Return sets up results that will be returned by PersistentIface.GetHistory
func (mmGetHistory *mPersistentIfaceMockGetHistory[T]) Return(p1 []*T, err error) *PersistentIfaceMock[T] {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("PersistentIfaceMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &PersistentIfaceMockGetHistoryExpectation[T]{mock: mmGetHistory.mock}
	}
	mmGetHistory.defaultExpectation.results = &PersistentIfaceMockGetHistoryResults[T]{p1, err}
	return mmGetHistory.mock
}

//Set uses given function f to mock the PersistentIface.GetHistory method
func (mmGetHistory *mPersistentIfaceMockGetHistory[T]) Set(f func(ctx context.Context) (p1 []*T, err error)) *PersistentIfaceMock[T] {
	if mmGetHistory.defaultExpectation != nil {
		mmGetHistory.mock.t.Fatalf("Default expectation is already set for the PersistentIface.GetHistory method")
	}

	if len(mmGetHistory.expectations) > 0 {
		mmGetHistory.mock.t.Fatalf("Some expectations are already set for the PersistentIface.GetHistory method")
	}

	mmGetHistory.mock.funcGetHistory = f
	return mmGetHistory.mock
}

// When sets expectation for the PersistentIface.GetHistory which will trigger the result defined by the following
// Then helper
func (mmGetHistory *mPersistentIfaceMockGetHistory[T]) When(ctx context.Context) *PersistentIfaceMockGetHistoryExpectation[T] {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("PersistentIfaceMock.GetHistory mock is already set by Set")
	}

	expectation := &PersistentIfaceMockGetHistoryExpectation[T]{
		mock:   mmGetHistory.mock,
		params: &PersistentIfaceMockGetHistoryParams{ctx},
	}
	mmGetHistory.expectations = append(mmGetHistory.expectations, expectation)
	return expectation
}

// Then sets up PersistentIface.GetHistory return parameters for the expectation previously defined by the When method
func (e *PersistentIfaceMockGetHistoryExpectation[T]) Then(p1 []*T, err error) *PersistentIfaceMock[T] {
	e.results = &PersistentIfaceMockGetHistoryResults[T]{p1, err}
	return e.mock
}

// GetHistory implements repo.PersistentIface
func (mmGetHistory *PersistentIfaceMock[T]) GetHistory(ctx context.Context) (p1 []*T, err error) {
	mm_atomic.AddUint64(&mmGetHistory.beforeGetHistoryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetHistory.afterGetHistoryCounter, 1)

	if mmGetHistory.inspectFuncGetHistory != nil {
		mmGetHistory.inspectFuncGetHistory(ctx)
	}

	mm_params := &PersistentIfaceMockGetHistoryParams{ctx}

	// Record call args
	mmGetHistory.GetHistoryMock.mutex.Lock()
	mmGetHistory.GetHistoryMock.callArgs = append(mmGetHistory.GetHistoryMock.callArgs, mm_params)
	mmGetHistory.GetHistoryMock.mutex.Unlock()

	for _, e := range mmGetHistory.GetHistoryMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetHistory.GetHistoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetHistory.GetHistoryMock.defaultExpectation.Counter, 1)
		mm_want := mmGetHistory.GetHistoryMock.defaultExpectation.params
		mm_got := PersistentIfaceMockGetHistoryParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetHistory.t.Errorf("PersistentIfaceMock.GetHistory got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetHistory.GetHistoryMock.defaultExpectation.results
		if mm_results == nil {
			mmGetHistory.t.Fatal("No results are set for the PersistentIfaceMock.GetHistory")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGetHistory.funcGetHistory != nil {
		return mmGetHistory.funcGetHistory(ctx)
	}
	mmGetHistory.t.Fatalf("Unexpected call to PersistentIfaceMock.GetHistory. %v", ctx)
	return
}

// GetHistoryAfterCounter returns a count of finished PersistentIfaceMock.GetHistory invocations
func (mmGetHistory *PersistentIfaceMock[T]) GetHistoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHistory.afterGetHistoryCounter)
}

// GetHistoryBeforeCounter returns a count of PersistentIfaceMock.GetHistory invocations
func (mmGetHistory *PersistentIfaceMock[T]) GetHistoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHistory.beforeGetHistoryCounter)
}

// Calls returns a list of arguments used in each call to PersistentIfaceMock.GetHistory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetHistory *mPersistentIfaceMockGetHistory[T]) Calls() []*PersistentIfaceMockGetHistoryParams {
	mmGetHistory.mutex.RLock()

	argCopy := make([]*PersistentIfaceMockGetHistoryParams, len(mmGetHistory.callArgs))
	copy(argCopy, mmGetHistory.callArgs)

	mmGetHistory.mutex.RUnlock()

	return argCopy
}

// MinimockGetHistoryDone returns true if the count of the GetHistory invocations corresponds
// the number of defined expectations
func (m *PersistentIfaceMock[T]) MinimockGetHistoryDone() bool {
	for _, e := range m.GetHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetHistoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetHistoryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetHistory != nil && mm_atomic.LoadUint64(&m.afterGetHistoryCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetHistoryInspect logs each unmet expectation
func (m *PersistentIfaceMock[T]) MinimockGetHistoryInspect() {
	for _, e := range m.GetHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersistentIfaceMock.GetHistory with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetHistoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetHistoryCounter) < 1 {
		if m.GetHistoryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PersistentIfaceMock.GetHistory")
		} else {
			m.t.Errorf("Expected call to PersistentIfaceMock.GetHistory with params: %#v", *m.GetHistoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetHistory != nil && mm_atomic.LoadUint64(&m.afterGetHistoryCounter) < 1 {
		m.t.Error("Expected call to PersistentIfaceMock.GetHistory")
	}
}

type mPersistentIfaceMockIsExist[T any] struct {
	mock               *PersistentIfaceMock[T]
	defaultExpectation *PersistentIfaceMockIsExistExpectation[T]
	expectations       []*PersistentIfaceMockIsExistExpectation[T]

	callArgs []*PersistentIfaceMockIsExistParams
	mutex    sync.RWMutex
}

// PersistentIfaceMockIsExistExpectation specifies expectation struct of the PersistentIface.IsExist
type PersistentIfaceMockIsExistExpectation[T any] struct {
	mock    *PersistentIfaceMock[T]
	params  *PersistentIfaceMockIsExistParams
	results *PersistentIfaceMockIsExistResults
	Counter uint64
}

// PersistentIfaceMockIsExistParams contains parameters of the PersistentIface.IsExist
type PersistentIfaceMockIsExistParams struct {
	ctx context.Context
	ID  string
}

// PersistentIfaceMockIsExistResults contains results of the PersistentIface.IsExist
type PersistentIfaceMockIsExistResults struct {
	b1 bool
}

// Expect sets up expected params for PersistentIface.IsExist
func (mmIsExist *mPersistentIfaceMockIsExist[T]) Expect(ctx context.Context, ID string) *mPersistentIfaceMockIsExist[T] {
	if mmIsExist.mock.funcIsExist != nil {
		mmIsExist.mock.t.Fatalf("PersistentIfaceMock.IsExist mock is already set by Set")
	}

	if mmIsExist.defaultExpectation == nil {
		mmIsExist.defaultExpectation = &PersistentIfaceMockIsExistExpectation[T]{}
	}

	mmIsExist.defaultExpectation.params = &PersistentIfaceMockIsExistParams{ctx, ID}
	for _, e := range mmIsExist.expectations {
		if minimock.Equal(e.params, mmIsExist.defaultExpectation.params) {
			mmIsExist.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsExist.defaultExpectation.params)
		}
	}

	return mmIsExist
}

// Inspect accepts an inspector function that has same arguments as the PersistentIface.IsExist
func (mmIsExist *mPersistentIfaceMockIsExist[T]) Inspect(f func(ctx context.Context, ID string)) *mPersistentIfaceMockIsExist[T] {
	if mmIsExist.mock.inspectFuncIsExist != nil {
		mmIsExist.mock.t.Fatalf("Inspect function is already set for PersistentIfaceMock.IsExist")
	}

	mmIsExist.mock.inspectFuncIsExist = f

	return mmIsExist
}

// Return sets up results that will be returned by PersistentIface.IsExist
func (mmIsExist *mPersistentIfaceMockIsExist[T]) Return(b1 bool) *PersistentIfaceMock[T] {
	if mmIsExist.mock.funcIsExist != nil {
		mmIsExist.mock.t.Fatalf("PersistentIfaceMock.IsExist mock is already set by Set")
	}

	if mmIsExist.defaultExpectation == nil {
		mmIsExist.defaultExpectation = &PersistentIfaceMockIsExistExpectation[T]{mock: mmIsExist.mock}
	}
	mmIsExist.defaultExpectation.results = &PersistentIfaceMockIsExistResults{b1}
	return mmIsExist.mock
}

//Set uses given function f to mock the PersistentIface.IsExist method
func (mmIsExist *mPersistentIfaceMockIsExist[T]) Set(f func(ctx context.Context, ID string) (b1 bool)) *PersistentIfaceMock[T] {
	if mmIsExist.defaultExpectation != nil {
		mmIsExist.mock.t.Fatalf("Default expectation is already set for the PersistentIface.IsExist method")
	}

	if len(mmIsExist.expectations) > 0 {
		mmIsExist.mock.t.Fatalf("Some expectations are already set for the PersistentIface.IsExist method")
	}

	mmIsExist.mock.funcIsExist = f
	return mmIsExist.mock
}

// When sets expectation for the PersistentIface.IsExist which will trigger the result defined by the following
// Then helper
func (mmIsExist *mPersistentIfaceMockIsExist[T]) When(ctx context.Context, ID string) *PersistentIfaceMockIsExistExpectation[T] {
	if mmIsExist.mock.funcIsExist != nil {
		mmIsExist.mock.t.Fatalf("PersistentIfaceMock.IsExist mock is already set by Set")
	}

	expectation := &PersistentIfaceMockIsExistExpectation[T]{
		mock:   mmIsExist.mock,
		params: &PersistentIfaceMockIsExistParams{ctx, ID},
	}
	mmIsExist.expectations = append(mmIsExist.expectations, expectation)
	return expectation
}

// Then sets up PersistentIface.IsExist return parameters for the expectation previously defined by the When method
func (e *PersistentIfaceMockIsExistExpectation[T]) Then(b1 bool) *PersistentIfaceMock[T] {
	e.results = &PersistentIfaceMockIsExistResults{b1}
	return e.mock
}

// IsExist implements repo.PersistentIface
func (mmIsExist *PersistentIfaceMock[T]) IsExist(ctx context.Context, ID string) (b1 bool) {
	mm_atomic.AddUint64(&mmIsExist.beforeIsExistCounter, 1)
	defer mm_atomic.AddUint64(&mmIsExist.afterIsExistCounter, 1)

	if mmIsExist.inspectFuncIsExist != nil {
		mmIsExist.inspectFuncIsExist(ctx, ID)
	}

	mm_params := &PersistentIfaceMockIsExistParams{ctx, ID}

	// Record call args
	mmIsExist.IsExistMock.mutex.Lock()
	mmIsExist.IsExistMock.callArgs = append(mmIsExist.IsExistMock.callArgs, mm_params)
	mmIsExist.IsExistMock.mutex.Unlock()

	for _, e := range mmIsExist.IsExistMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsExist.IsExistMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsExist.IsExistMock.defaultExpectation.Counter, 1)
		mm_want := mmIsExist.IsExistMock.defaultExpectation.params
		mm_got := PersistentIfaceMockIsExistParams{ctx, ID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsExist.t.Errorf("PersistentIfaceMock.IsExist got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsExist.IsExistMock.defaultExpectation.results
		if mm_results == nil {
			mmIsExist.t.Fatal("No results are set for the PersistentIfaceMock.IsExist")
		}
		return (*mm_results).b1
	}
	if mmIsExist.funcIsExist != nil {
		return mmIsExist.funcIsExist(ctx, ID)
	}
	mmIsExist.t.Fatalf("Unexpected call to PersistentIfaceMock.IsExist. %v %v", ctx, ID)
	return
}

// IsExistAfterCounter returns a count of finished PersistentIfaceMock.IsExist invocations
func (mmIsExist *PersistentIfaceMock[T]) IsExistAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsExist.afterIsExistCounter)
}

// IsExistBeforeCounter returns a count of PersistentIfaceMock.IsExist invocations
func (mmIsExist *PersistentIfaceMock[T]) IsExistBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsExist.beforeIsExistCounter)
}

// Calls returns a list of arguments used in each call to PersistentIfaceMock.IsExist.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsExist *mPersistentIfaceMockIsExist[T]) Calls() []*PersistentIfaceMockIsExistParams {
	mmIsExist.mutex.RLock()

	argCopy := make([]*PersistentIfaceMockIsExistParams, len(mmIsExist.callArgs))
	copy(argCopy, mmIsExist.callArgs)

	mmIsExist.mutex.RUnlock()

	return argCopy
}

// MinimockIsExistDone returns true if the count of the IsExist invocations corresponds
// the number of defined expectations
func (m *PersistentIfaceMock[T]) MinimockIsExistDone() bool {
	for _, e := range m.IsExistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsExistMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsExistCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsExist != nil && mm_atomic.LoadUint64(&m.afterIsExistCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsExistInspect logs each unmet expectation
func (m *PersistentIfaceMock[T]) MinimockIsExistInspect() {
	for _, e := range m.IsExistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersistentIfaceMock.IsExist with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsExistMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsExistCounter) < 1 {
		if m.IsExistMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PersistentIfaceMock.IsExist")
		} else {
			m.t.Errorf("Expected call to PersistentIfaceMock.IsExist with params: %#v", *m.IsExistMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsExist != nil && mm_atomic.LoadUint64(&m.afterIsExistCounter) < 1 {
		m.t.Error("Expected call to PersistentIfaceMock.IsExist")
	}
}

type mPersistentIfaceMockStore[T any] struct {
	mock               *PersistentIfaceMock[T]
	defaultExpectation *PersistentIfaceMockStoreExpectation[T]
	expectations       []*PersistentIfaceMockStoreExpectation[T]

	callArgs []*PersistentIfaceMockStoreParams
	mutex    sync.RWMutex
}

// PersistentIfaceMockStoreExpectation specifies expectation struct of the PersistentIface.Store
type PersistentIfaceMockStoreExpectation[T any] struct {
	mock    *PersistentIfaceMock[T]
	params  *PersistentIfaceMockStoreParams
	results *PersistentIfaceMockStoreResults
	Counter uint64
}

// PersistentIfaceMockStoreParams contains parameters of the PersistentIface.Store
type PersistentIfaceMockStoreParams struct {
	ctx context.Context
	ID  string
	e   interface{}
}

// PersistentIfaceMockStoreResults contains results of the PersistentIface.Store
type PersistentIfaceMockStoreResults struct {
	err error
}

// Expect sets up expected params for PersistentIface.Store
func (mmStore *mPersistentIfaceMockStore[T]) Expect(ctx context.Context, ID string, e interface{}) *mPersistentIfaceMockStore[T] {
	if mmStore.mock.funcStore != nil {
		mmStore.mock.t.Fatalf("PersistentIfaceMock.Store mock is already set by Set")
	}

	if mmStore.defaultExpectation == nil {
		mmStore.defaultExpectation = &PersistentIfaceMockStoreExpectation[T]{}
	}

	mmStore.defaultExpectation.params = &PersistentIfaceMockStoreParams{ctx, ID, e}
	for _, e := range mmStore.expectations {
		if minimock.Equal(e.params, mmStore.defaultExpectation.params) {
			mmStore.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStore.defaultExpectation.params)
		}
	}

	return mmStore
}

// Inspect accepts an inspector function that has same arguments as the PersistentIface.Store
func (mmStore *mPersistentIfaceMockStore[T]) Inspect(f func(ctx context.Context, ID string, e *T)) *mPersistentIfaceMockStore[T] {
	if mmStore.mock.inspectFuncStore != nil {
		mmStore.mock.t.Fatalf("Inspect function is already set for PersistentIfaceMock.Store")
	}

	mmStore.mock.inspectFuncStore = f

	return mmStore
}

// Return sets up results that will be returned by PersistentIface.Store
func (mmStore *mPersistentIfaceMockStore[T]) Return(err error) *PersistentIfaceMock[T] {
	if mmStore.mock.funcStore != nil {
		mmStore.mock.t.Fatalf("PersistentIfaceMock.Store mock is already set by Set")
	}

	if mmStore.defaultExpectation == nil {
		mmStore.defaultExpectation = &PersistentIfaceMockStoreExpectation[T]{mock: mmStore.mock}
	}
	mmStore.defaultExpectation.results = &PersistentIfaceMockStoreResults{err}
	return mmStore.mock
}

//Set uses given function f to mock the PersistentIface.Store method
func (mmStore *mPersistentIfaceMockStore[T]) Set(f func(ctx context.Context, ID string, e *T) (err error)) *PersistentIfaceMock[T] {
	if mmStore.defaultExpectation != nil {
		mmStore.mock.t.Fatalf("Default expectation is already set for the PersistentIface.Store method")
	}

	if len(mmStore.expectations) > 0 {
		mmStore.mock.t.Fatalf("Some expectations are already set for the PersistentIface.Store method")
	}

	mmStore.mock.funcStore = f
	return mmStore.mock
}

// When sets expectation for the PersistentIface.Store which will trigger the result defined by the following
// Then helper
func (mmStore *mPersistentIfaceMockStore[T]) When(ctx context.Context, ID string, e *T) *PersistentIfaceMockStoreExpectation[T] {
	if mmStore.mock.funcStore != nil {
		mmStore.mock.t.Fatalf("PersistentIfaceMock.Store mock is already set by Set")
	}

	expectation := &PersistentIfaceMockStoreExpectation[T]{
		mock:   mmStore.mock,
		params: &PersistentIfaceMockStoreParams{ctx, ID, e},
	}
	mmStore.expectations = append(mmStore.expectations, expectation)
	return expectation
}

// Then sets up PersistentIface.Store return parameters for the expectation previously defined by the When method
func (e *PersistentIfaceMockStoreExpectation[T]) Then(err error) *PersistentIfaceMock[T] {
	e.results = &PersistentIfaceMockStoreResults{err}
	return e.mock
}

// Store implements repo.PersistentIface
func (mmStore *PersistentIfaceMock[T]) Store(ctx context.Context, ID string, e *T) (err error) {
	mm_atomic.AddUint64(&mmStore.beforeStoreCounter, 1)
	defer mm_atomic.AddUint64(&mmStore.afterStoreCounter, 1)

	if mmStore.inspectFuncStore != nil {
		mmStore.inspectFuncStore(ctx, ID, e)
	}

	mm_params := &PersistentIfaceMockStoreParams{ctx, ID, e}

	// Record call args
	mmStore.StoreMock.mutex.Lock()
	mmStore.StoreMock.callArgs = append(mmStore.StoreMock.callArgs, mm_params)
	mmStore.StoreMock.mutex.Unlock()

	for _, e := range mmStore.StoreMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStore.StoreMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStore.StoreMock.defaultExpectation.Counter, 1)
		mm_want := mmStore.StoreMock.defaultExpectation.params
		mm_got := PersistentIfaceMockStoreParams{ctx, ID, e}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStore.t.Errorf("PersistentIfaceMock.Store got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStore.StoreMock.defaultExpectation.results
		if mm_results == nil {
			mmStore.t.Fatal("No results are set for the PersistentIfaceMock.Store")
		}
		return (*mm_results).err
	}
	if mmStore.funcStore != nil {
		return mmStore.funcStore(ctx, ID, e)
	}
	mmStore.t.Fatalf("Unexpected call to PersistentIfaceMock.Store. %v %v %v", ctx, ID, e)
	return
}

// StoreAfterCounter returns a count of finished PersistentIfaceMock.Store invocations
func (mmStore *PersistentIfaceMock[T]) StoreAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStore.afterStoreCounter)
}

// StoreBeforeCounter returns a count of PersistentIfaceMock.Store invocations
func (mmStore *PersistentIfaceMock[T]) StoreBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStore.beforeStoreCounter)
}

// Calls returns a list of arguments used in each call to PersistentIfaceMock.Store.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStore *mPersistentIfaceMockStore[T]) Calls() []*PersistentIfaceMockStoreParams {
	mmStore.mutex.RLock()

	argCopy := make([]*PersistentIfaceMockStoreParams, len(mmStore.callArgs))
	copy(argCopy, mmStore.callArgs)

	mmStore.mutex.RUnlock()

	return argCopy
}

// MinimockStoreDone returns true if the count of the Store invocations corresponds
// the number of defined expectations
func (m *PersistentIfaceMock[T]) MinimockStoreDone() bool {
	for _, e := range m.StoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StoreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStoreCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStore != nil && mm_atomic.LoadUint64(&m.afterStoreCounter) < 1 {
		return false
	}
	return true
}

// MinimockStoreInspect logs each unmet expectation
func (m *PersistentIfaceMock[T]) MinimockStoreInspect() {
	for _, e := range m.StoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersistentIfaceMock.Store with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StoreMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStoreCounter) < 1 {
		if m.StoreMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PersistentIfaceMock.Store")
		} else {
			m.t.Errorf("Expected call to PersistentIfaceMock.Store with params: %#v", *m.StoreMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStore != nil && mm_atomic.LoadUint64(&m.afterStoreCounter) < 1 {
		m.t.Error("Expected call to PersistentIfaceMock.Store")
	}
}

type mPersistentIfaceMockStoreTable[T any] struct {
	mock               *PersistentIfaceMock[T]
	defaultExpectation *PersistentIfaceMockStoreTableExpectation[T]
	expectations       []*PersistentIfaceMockStoreTableExpectation[T]

	callArgs []*PersistentIfaceMockStoreTableParams[T]
	mutex    sync.RWMutex
}

// PersistentIfaceMockStoreTableExpectation specifies expectation struct of the PersistentIface.StoreTable
type PersistentIfaceMockStoreTableExpectation[T any] struct {
	mock    *PersistentIfaceMock[T]
	params  *PersistentIfaceMockStoreTableParams[T]
	results *PersistentIfaceMockStoreTableResults
	Counter uint64
}

// PersistentIfaceMockStoreTableParams contains parameters of the PersistentIface.StoreTable
type PersistentIfaceMockStoreTableParams[T any] struct {
	ctx  context.Context
	emap map[string]*T
}

// PersistentIfaceMockStoreTableResults contains results of the PersistentIface.StoreTable
type PersistentIfaceMockStoreTableResults struct {
	err error
}

// Expect sets up expected params for PersistentIface.StoreTable
func (mmStoreTable *mPersistentIfaceMockStoreTable[T]) Expect(ctx context.Context, emap map[string]*T) *mPersistentIfaceMockStoreTable[T] {
	if mmStoreTable.mock.funcStoreTable != nil {
		mmStoreTable.mock.t.Fatalf("PersistentIfaceMock.StoreTable mock is already set by Set")
	}

	if mmStoreTable.defaultExpectation == nil {
		mmStoreTable.defaultExpectation = &PersistentIfaceMockStoreTableExpectation[T]{}
	}

	mmStoreTable.defaultExpectation.params = &PersistentIfaceMockStoreTableParams[T]{ctx, emap}
	for _, e := range mmStoreTable.expectations {
		if minimock.Equal(e.params, mmStoreTable.defaultExpectation.params) {
			mmStoreTable.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStoreTable.defaultExpectation.params)
		}
	}

	return mmStoreTable
}

// Inspect accepts an inspector function that has same arguments as the PersistentIface.StoreTable
func (mmStoreTable *mPersistentIfaceMockStoreTable[T]) Inspect(f func(ctx context.Context, emap map[string]*T)) *mPersistentIfaceMockStoreTable[T] {
	if mmStoreTable.mock.inspectFuncStoreTable != nil {
		mmStoreTable.mock.t.Fatalf("Inspect function is already set for PersistentIfaceMock.StoreTable")
	}

	mmStoreTable.mock.inspectFuncStoreTable = f

	return mmStoreTable
}

// Return sets up results that will be returned by PersistentIface.StoreTable
func (mmStoreTable *mPersistentIfaceMockStoreTable[T]) Return(err error) *PersistentIfaceMock[T] {
	if mmStoreTable.mock.funcStoreTable != nil {
		mmStoreTable.mock.t.Fatalf("PersistentIfaceMock.StoreTable mock is already set by Set")
	}

	if mmStoreTable.defaultExpectation == nil {
		mmStoreTable.defaultExpectation = &PersistentIfaceMockStoreTableExpectation[T]{mock: mmStoreTable.mock}
	}
	mmStoreTable.defaultExpectation.results = &PersistentIfaceMockStoreTableResults{err}
	return mmStoreTable.mock
}

//Set uses given function f to mock the PersistentIface.StoreTable method
func (mmStoreTable *mPersistentIfaceMockStoreTable[T]) Set(f func(ctx context.Context, emap map[string]*T) (err error)) *PersistentIfaceMock[T] {
	if mmStoreTable.defaultExpectation != nil {
		mmStoreTable.mock.t.Fatalf("Default expectation is already set for the PersistentIface.StoreTable method")
	}

	if len(mmStoreTable.expectations) > 0 {
		mmStoreTable.mock.t.Fatalf("Some expectations are already set for the PersistentIface.StoreTable method")
	}

	mmStoreTable.mock.funcStoreTable = f
	return mmStoreTable.mock
}

// When sets expectation for the PersistentIface.StoreTable which will trigger the result defined by the following
// Then helper
func (mmStoreTable *mPersistentIfaceMockStoreTable[T]) When(ctx context.Context, emap map[string]*T) *PersistentIfaceMockStoreTableExpectation[T] {
	if mmStoreTable.mock.funcStoreTable != nil {
		mmStoreTable.mock.t.Fatalf("PersistentIfaceMock.StoreTable mock is already set by Set")
	}

	expectation := &PersistentIfaceMockStoreTableExpectation[T]{
		mock:   mmStoreTable.mock,
		params: &PersistentIfaceMockStoreTableParams[T]{ctx, emap},
	}
	mmStoreTable.expectations = append(mmStoreTable.expectations, expectation)
	return expectation
}

// Then sets up PersistentIface.StoreTable return parameters for the expectation previously defined by the When method
func (e *PersistentIfaceMockStoreTableExpectation[T]) Then(err error) *PersistentIfaceMock[T] {
	e.results = &PersistentIfaceMockStoreTableResults{err}
	return e.mock
}

// StoreTable implements repo.PersistentIface
func (mmStoreTable *PersistentIfaceMock[T]) StoreTable(ctx context.Context, emap map[string]*T) (err error) {
	mm_atomic.AddUint64(&mmStoreTable.beforeStoreTableCounter, 1)
	defer mm_atomic.AddUint64(&mmStoreTable.afterStoreTableCounter, 1)

	if mmStoreTable.inspectFuncStoreTable != nil {
		mmStoreTable.inspectFuncStoreTable(ctx, emap)
	}

	mm_params := &PersistentIfaceMockStoreTableParams[T]{ctx, emap}

	// Record call args
	mmStoreTable.StoreTableMock.mutex.Lock()
	mmStoreTable.StoreTableMock.callArgs = append(mmStoreTable.StoreTableMock.callArgs, mm_params)
	mmStoreTable.StoreTableMock.mutex.Unlock()

	for _, e := range mmStoreTable.StoreTableMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStoreTable.StoreTableMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStoreTable.StoreTableMock.defaultExpectation.Counter, 1)
		mm_want := mmStoreTable.StoreTableMock.defaultExpectation.params
		mm_got := PersistentIfaceMockStoreTableParams[T]{ctx, emap}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStoreTable.t.Errorf("PersistentIfaceMock.StoreTable got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStoreTable.StoreTableMock.defaultExpectation.results
		if mm_results == nil {
			mmStoreTable.t.Fatal("No results are set for the PersistentIfaceMock.StoreTable")
		}
		return (*mm_results).err
	}
	if mmStoreTable.funcStoreTable != nil {
		return mmStoreTable.funcStoreTable(ctx, emap)
	}
	mmStoreTable.t.Fatalf("Unexpected call to PersistentIfaceMock.StoreTable. %v %v", ctx, emap)
	return
}

// StoreTableAfterCounter returns a count of finished PersistentIfaceMock.StoreTable invocations
func (mmStoreTable *PersistentIfaceMock[T]) StoreTableAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStoreTable.afterStoreTableCounter)
}

// StoreTableBeforeCounter returns a count of PersistentIfaceMock.StoreTable invocations
func (mmStoreTable *PersistentIfaceMock[T]) StoreTableBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStoreTable.beforeStoreTableCounter)
}

// Calls returns a list of arguments used in each call to PersistentIfaceMock.StoreTable.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStoreTable *mPersistentIfaceMockStoreTable[T]) Calls() []*PersistentIfaceMockStoreTableParams[T] {
	mmStoreTable.mutex.RLock()

	argCopy := make([]*PersistentIfaceMockStoreTableParams[T], len(mmStoreTable.callArgs))
	copy(argCopy, mmStoreTable.callArgs)

	mmStoreTable.mutex.RUnlock()

	return argCopy
}

// MinimockStoreTableDone returns true if the count of the StoreTable invocations corresponds
// the number of defined expectations
func (m *PersistentIfaceMock[T]) MinimockStoreTableDone() bool {
	for _, e := range m.StoreTableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StoreTableMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStoreTableCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStoreTable != nil && mm_atomic.LoadUint64(&m.afterStoreTableCounter) < 1 {
		return false
	}
	return true
}

// MinimockStoreTableInspect logs each unmet expectation
func (m *PersistentIfaceMock[T]) MinimockStoreTableInspect() {
	for _, e := range m.StoreTableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersistentIfaceMock.StoreTable with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StoreTableMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStoreTableCounter) < 1 {
		if m.StoreTableMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PersistentIfaceMock.StoreTable")
		} else {
			m.t.Errorf("Expected call to PersistentIfaceMock.StoreTable with params: %#v", *m.StoreTableMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStoreTable != nil && mm_atomic.LoadUint64(&m.afterStoreTableCounter) < 1 {
		m.t.Error("Expected call to PersistentIfaceMock.StoreTable")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PersistentIfaceMock[T]) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDeleteInspect()

		m.MinimockFlushInspect()

		m.MinimockGetActiveInspect()

		m.MinimockGetHistoryInspect()

		m.MinimockIsExistInspect()

		m.MinimockStoreInspect()

		m.MinimockStoreTableInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PersistentIfaceMock[T]) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PersistentIfaceMock[T]) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteDone() &&
		m.MinimockFlushDone() &&
		m.MinimockGetActiveDone() &&
		m.MinimockGetHistoryDone() &&
		m.MinimockIsExistDone() &&
		m.MinimockStoreDone() &&
		m.MinimockStoreTableDone()
}
