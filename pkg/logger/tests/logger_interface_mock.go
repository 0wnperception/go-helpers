package tests

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i robot_agent/pkg/logger.LoggerInterface -o ./tests/logger_interface_mock.go -n LoggerInterfaceMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LoggerInterfaceMock implements logger.LoggerInterface
type LoggerInterfaceMock struct {
	t minimock.Tester

	funcDebug          func(msg string, arg string, val string)
	inspectFuncDebug   func(msg string, arg string, val string)
	afterDebugCounter  uint64
	beforeDebugCounter uint64
	DebugMock          mLoggerInterfaceMockDebug

	funcError          func(msg string, err error)
	inspectFuncError   func(msg string, err error)
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mLoggerInterfaceMockError

	funcFatal          func(msg string, err error)
	inspectFuncFatal   func(msg string, err error)
	afterFatalCounter  uint64
	beforeFatalCounter uint64
	FatalMock          mLoggerInterfaceMockFatal

	funcInfo          func(msg string, arg string, val string)
	inspectFuncInfo   func(msg string, arg string, val string)
	afterInfoCounter  uint64
	beforeInfoCounter uint64
	InfoMock          mLoggerInterfaceMockInfo

	funcRelease          func()
	inspectFuncRelease   func()
	afterReleaseCounter  uint64
	beforeReleaseCounter uint64
	ReleaseMock          mLoggerInterfaceMockRelease

	funcWarn          func(msg string, arg string, val string)
	inspectFuncWarn   func(msg string, arg string, val string)
	afterWarnCounter  uint64
	beforeWarnCounter uint64
	WarnMock          mLoggerInterfaceMockWarn
}

// NewLoggerInterfaceMock returns a mock for logger.LoggerInterface
func NewLoggerInterfaceMock(t minimock.Tester) *LoggerInterfaceMock {
	m := &LoggerInterfaceMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DebugMock = mLoggerInterfaceMockDebug{mock: m}
	m.DebugMock.callArgs = []*LoggerInterfaceMockDebugParams{}

	m.ErrorMock = mLoggerInterfaceMockError{mock: m}
	m.ErrorMock.callArgs = []*LoggerInterfaceMockErrorParams{}

	m.FatalMock = mLoggerInterfaceMockFatal{mock: m}
	m.FatalMock.callArgs = []*LoggerInterfaceMockFatalParams{}

	m.InfoMock = mLoggerInterfaceMockInfo{mock: m}
	m.InfoMock.callArgs = []*LoggerInterfaceMockInfoParams{}

	m.ReleaseMock = mLoggerInterfaceMockRelease{mock: m}

	m.WarnMock = mLoggerInterfaceMockWarn{mock: m}
	m.WarnMock.callArgs = []*LoggerInterfaceMockWarnParams{}

	return m
}

type mLoggerInterfaceMockDebug struct {
	mock               *LoggerInterfaceMock
	defaultExpectation *LoggerInterfaceMockDebugExpectation
	expectations       []*LoggerInterfaceMockDebugExpectation

	callArgs []*LoggerInterfaceMockDebugParams
	mutex    sync.RWMutex
}

// LoggerInterfaceMockDebugExpectation specifies expectation struct of the LoggerInterface.Debug
type LoggerInterfaceMockDebugExpectation struct {
	mock   *LoggerInterfaceMock
	params *LoggerInterfaceMockDebugParams

	Counter uint64
}

// LoggerInterfaceMockDebugParams contains parameters of the LoggerInterface.Debug
type LoggerInterfaceMockDebugParams struct {
	msg string
	arg string
	val string
}

// Expect sets up expected params for LoggerInterface.Debug
func (mmDebug *mLoggerInterfaceMockDebug) Expect(msg string, arg string, val string) *mLoggerInterfaceMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerInterfaceMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerInterfaceMockDebugExpectation{}
	}

	mmDebug.defaultExpectation.params = &LoggerInterfaceMockDebugParams{msg, arg, val}
	for _, e := range mmDebug.expectations {
		if minimock.Equal(e.params, mmDebug.defaultExpectation.params) {
			mmDebug.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebug.defaultExpectation.params)
		}
	}

	return mmDebug
}

// Inspect accepts an inspector function that has same arguments as the LoggerInterface.Debug
func (mmDebug *mLoggerInterfaceMockDebug) Inspect(f func(msg string, arg string, val string)) *mLoggerInterfaceMockDebug {
	if mmDebug.mock.inspectFuncDebug != nil {
		mmDebug.mock.t.Fatalf("Inspect function is already set for LoggerInterfaceMock.Debug")
	}

	mmDebug.mock.inspectFuncDebug = f

	return mmDebug
}

// Return sets up results that will be returned by LoggerInterface.Debug
func (mmDebug *mLoggerInterfaceMockDebug) Return() *LoggerInterfaceMock {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerInterfaceMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerInterfaceMockDebugExpectation{mock: mmDebug.mock}
	}

	return mmDebug.mock
}

//Set uses given function f to mock the LoggerInterface.Debug method
func (mmDebug *mLoggerInterfaceMockDebug) Set(f func(msg string, arg string, val string)) *LoggerInterfaceMock {
	if mmDebug.defaultExpectation != nil {
		mmDebug.mock.t.Fatalf("Default expectation is already set for the LoggerInterface.Debug method")
	}

	if len(mmDebug.expectations) > 0 {
		mmDebug.mock.t.Fatalf("Some expectations are already set for the LoggerInterface.Debug method")
	}

	mmDebug.mock.funcDebug = f
	return mmDebug.mock
}

// Debug implements logger.LoggerInterface
func (mmDebug *LoggerInterfaceMock) Debug(msg string, arg string, val string) {
	mm_atomic.AddUint64(&mmDebug.beforeDebugCounter, 1)
	defer mm_atomic.AddUint64(&mmDebug.afterDebugCounter, 1)

	if mmDebug.inspectFuncDebug != nil {
		mmDebug.inspectFuncDebug(msg, arg, val)
	}

	mm_params := &LoggerInterfaceMockDebugParams{msg, arg, val}

	// Record call args
	mmDebug.DebugMock.mutex.Lock()
	mmDebug.DebugMock.callArgs = append(mmDebug.DebugMock.callArgs, mm_params)
	mmDebug.DebugMock.mutex.Unlock()

	for _, e := range mmDebug.DebugMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebug.DebugMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebug.DebugMock.defaultExpectation.Counter, 1)
		mm_want := mmDebug.DebugMock.defaultExpectation.params
		mm_got := LoggerInterfaceMockDebugParams{msg, arg, val}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebug.t.Errorf("LoggerInterfaceMock.Debug got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebug.funcDebug != nil {
		mmDebug.funcDebug(msg, arg, val)
		return
	}
	mmDebug.t.Fatalf("Unexpected call to LoggerInterfaceMock.Debug. %v %v %v", msg, arg, val)

}

// DebugAfterCounter returns a count of finished LoggerInterfaceMock.Debug invocations
func (mmDebug *LoggerInterfaceMock) DebugAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.afterDebugCounter)
}

// DebugBeforeCounter returns a count of LoggerInterfaceMock.Debug invocations
func (mmDebug *LoggerInterfaceMock) DebugBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.beforeDebugCounter)
}

// Calls returns a list of arguments used in each call to LoggerInterfaceMock.Debug.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebug *mLoggerInterfaceMockDebug) Calls() []*LoggerInterfaceMockDebugParams {
	mmDebug.mutex.RLock()

	argCopy := make([]*LoggerInterfaceMockDebugParams, len(mmDebug.callArgs))
	copy(argCopy, mmDebug.callArgs)

	mmDebug.mutex.RUnlock()

	return argCopy
}

// MinimockDebugDone returns true if the count of the Debug invocations corresponds
// the number of defined expectations
func (m *LoggerInterfaceMock) MinimockDebugDone() bool {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		return false
	}
	return true
}

// MinimockDebugInspect logs each unmet expectation
func (m *LoggerInterfaceMock) MinimockDebugInspect() {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerInterfaceMock.Debug with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		if m.DebugMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerInterfaceMock.Debug")
		} else {
			m.t.Errorf("Expected call to LoggerInterfaceMock.Debug with params: %#v", *m.DebugMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		m.t.Error("Expected call to LoggerInterfaceMock.Debug")
	}
}

type mLoggerInterfaceMockError struct {
	mock               *LoggerInterfaceMock
	defaultExpectation *LoggerInterfaceMockErrorExpectation
	expectations       []*LoggerInterfaceMockErrorExpectation

	callArgs []*LoggerInterfaceMockErrorParams
	mutex    sync.RWMutex
}

// LoggerInterfaceMockErrorExpectation specifies expectation struct of the LoggerInterface.Error
type LoggerInterfaceMockErrorExpectation struct {
	mock   *LoggerInterfaceMock
	params *LoggerInterfaceMockErrorParams

	Counter uint64
}

// LoggerInterfaceMockErrorParams contains parameters of the LoggerInterface.Error
type LoggerInterfaceMockErrorParams struct {
	msg string
	err error
}

// Expect sets up expected params for LoggerInterface.Error
func (mmError *mLoggerInterfaceMockError) Expect(msg string, err error) *mLoggerInterfaceMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerInterfaceMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerInterfaceMockErrorExpectation{}
	}

	mmError.defaultExpectation.params = &LoggerInterfaceMockErrorParams{msg, err}
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the LoggerInterface.Error
func (mmError *mLoggerInterfaceMockError) Inspect(f func(msg string, err error)) *mLoggerInterfaceMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for LoggerInterfaceMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by LoggerInterface.Error
func (mmError *mLoggerInterfaceMockError) Return() *LoggerInterfaceMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerInterfaceMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerInterfaceMockErrorExpectation{mock: mmError.mock}
	}

	return mmError.mock
}

//Set uses given function f to mock the LoggerInterface.Error method
func (mmError *mLoggerInterfaceMockError) Set(f func(msg string, err error)) *LoggerInterfaceMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the LoggerInterface.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the LoggerInterface.Error method")
	}

	mmError.mock.funcError = f
	return mmError.mock
}

// Error implements logger.LoggerInterface
func (mmError *LoggerInterfaceMock) Error(msg string, err error) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(msg, err)
	}

	mm_params := &LoggerInterfaceMockErrorParams{msg, err}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_got := LoggerInterfaceMockErrorParams{msg, err}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("LoggerInterfaceMock.Error got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmError.funcError != nil {
		mmError.funcError(msg, err)
		return
	}
	mmError.t.Fatalf("Unexpected call to LoggerInterfaceMock.Error. %v %v", msg, err)

}

// ErrorAfterCounter returns a count of finished LoggerInterfaceMock.Error invocations
func (mmError *LoggerInterfaceMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of LoggerInterfaceMock.Error invocations
func (mmError *LoggerInterfaceMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to LoggerInterfaceMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mLoggerInterfaceMockError) Calls() []*LoggerInterfaceMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*LoggerInterfaceMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *LoggerInterfaceMock) MinimockErrorDone() bool {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrorInspect logs each unmet expectation
func (m *LoggerInterfaceMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerInterfaceMock.Error with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerInterfaceMock.Error")
		} else {
			m.t.Errorf("Expected call to LoggerInterfaceMock.Error with params: %#v", *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		m.t.Error("Expected call to LoggerInterfaceMock.Error")
	}
}

type mLoggerInterfaceMockFatal struct {
	mock               *LoggerInterfaceMock
	defaultExpectation *LoggerInterfaceMockFatalExpectation
	expectations       []*LoggerInterfaceMockFatalExpectation

	callArgs []*LoggerInterfaceMockFatalParams
	mutex    sync.RWMutex
}

// LoggerInterfaceMockFatalExpectation specifies expectation struct of the LoggerInterface.Fatal
type LoggerInterfaceMockFatalExpectation struct {
	mock   *LoggerInterfaceMock
	params *LoggerInterfaceMockFatalParams

	Counter uint64
}

// LoggerInterfaceMockFatalParams contains parameters of the LoggerInterface.Fatal
type LoggerInterfaceMockFatalParams struct {
	msg string
	err error
}

// Expect sets up expected params for LoggerInterface.Fatal
func (mmFatal *mLoggerInterfaceMockFatal) Expect(msg string, err error) *mLoggerInterfaceMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerInterfaceMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerInterfaceMockFatalExpectation{}
	}

	mmFatal.defaultExpectation.params = &LoggerInterfaceMockFatalParams{msg, err}
	for _, e := range mmFatal.expectations {
		if minimock.Equal(e.params, mmFatal.defaultExpectation.params) {
			mmFatal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFatal.defaultExpectation.params)
		}
	}

	return mmFatal
}

// Inspect accepts an inspector function that has same arguments as the LoggerInterface.Fatal
func (mmFatal *mLoggerInterfaceMockFatal) Inspect(f func(msg string, err error)) *mLoggerInterfaceMockFatal {
	if mmFatal.mock.inspectFuncFatal != nil {
		mmFatal.mock.t.Fatalf("Inspect function is already set for LoggerInterfaceMock.Fatal")
	}

	mmFatal.mock.inspectFuncFatal = f

	return mmFatal
}

// Return sets up results that will be returned by LoggerInterface.Fatal
func (mmFatal *mLoggerInterfaceMockFatal) Return() *LoggerInterfaceMock {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerInterfaceMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerInterfaceMockFatalExpectation{mock: mmFatal.mock}
	}

	return mmFatal.mock
}

//Set uses given function f to mock the LoggerInterface.Fatal method
func (mmFatal *mLoggerInterfaceMockFatal) Set(f func(msg string, err error)) *LoggerInterfaceMock {
	if mmFatal.defaultExpectation != nil {
		mmFatal.mock.t.Fatalf("Default expectation is already set for the LoggerInterface.Fatal method")
	}

	if len(mmFatal.expectations) > 0 {
		mmFatal.mock.t.Fatalf("Some expectations are already set for the LoggerInterface.Fatal method")
	}

	mmFatal.mock.funcFatal = f
	return mmFatal.mock
}

// Fatal implements logger.LoggerInterface
func (mmFatal *LoggerInterfaceMock) Fatal(msg string, err error) {
	mm_atomic.AddUint64(&mmFatal.beforeFatalCounter, 1)
	defer mm_atomic.AddUint64(&mmFatal.afterFatalCounter, 1)

	if mmFatal.inspectFuncFatal != nil {
		mmFatal.inspectFuncFatal(msg, err)
	}

	mm_params := &LoggerInterfaceMockFatalParams{msg, err}

	// Record call args
	mmFatal.FatalMock.mutex.Lock()
	mmFatal.FatalMock.callArgs = append(mmFatal.FatalMock.callArgs, mm_params)
	mmFatal.FatalMock.mutex.Unlock()

	for _, e := range mmFatal.FatalMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFatal.FatalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFatal.FatalMock.defaultExpectation.Counter, 1)
		mm_want := mmFatal.FatalMock.defaultExpectation.params
		mm_got := LoggerInterfaceMockFatalParams{msg, err}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFatal.t.Errorf("LoggerInterfaceMock.Fatal got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmFatal.funcFatal != nil {
		mmFatal.funcFatal(msg, err)
		return
	}
	mmFatal.t.Fatalf("Unexpected call to LoggerInterfaceMock.Fatal. %v %v", msg, err)

}

// FatalAfterCounter returns a count of finished LoggerInterfaceMock.Fatal invocations
func (mmFatal *LoggerInterfaceMock) FatalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.afterFatalCounter)
}

// FatalBeforeCounter returns a count of LoggerInterfaceMock.Fatal invocations
func (mmFatal *LoggerInterfaceMock) FatalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.beforeFatalCounter)
}

// Calls returns a list of arguments used in each call to LoggerInterfaceMock.Fatal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFatal *mLoggerInterfaceMockFatal) Calls() []*LoggerInterfaceMockFatalParams {
	mmFatal.mutex.RLock()

	argCopy := make([]*LoggerInterfaceMockFatalParams, len(mmFatal.callArgs))
	copy(argCopy, mmFatal.callArgs)

	mmFatal.mutex.RUnlock()

	return argCopy
}

// MinimockFatalDone returns true if the count of the Fatal invocations corresponds
// the number of defined expectations
func (m *LoggerInterfaceMock) MinimockFatalDone() bool {
	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FatalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatal != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		return false
	}
	return true
}

// MinimockFatalInspect logs each unmet expectation
func (m *LoggerInterfaceMock) MinimockFatalInspect() {
	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerInterfaceMock.Fatal with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FatalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		if m.FatalMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerInterfaceMock.Fatal")
		} else {
			m.t.Errorf("Expected call to LoggerInterfaceMock.Fatal with params: %#v", *m.FatalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatal != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		m.t.Error("Expected call to LoggerInterfaceMock.Fatal")
	}
}

type mLoggerInterfaceMockInfo struct {
	mock               *LoggerInterfaceMock
	defaultExpectation *LoggerInterfaceMockInfoExpectation
	expectations       []*LoggerInterfaceMockInfoExpectation

	callArgs []*LoggerInterfaceMockInfoParams
	mutex    sync.RWMutex
}

// LoggerInterfaceMockInfoExpectation specifies expectation struct of the LoggerInterface.Info
type LoggerInterfaceMockInfoExpectation struct {
	mock   *LoggerInterfaceMock
	params *LoggerInterfaceMockInfoParams

	Counter uint64
}

// LoggerInterfaceMockInfoParams contains parameters of the LoggerInterface.Info
type LoggerInterfaceMockInfoParams struct {
	msg string
	arg string
	val string
}

// Expect sets up expected params for LoggerInterface.Info
func (mmInfo *mLoggerInterfaceMockInfo) Expect(msg string, arg string, val string) *mLoggerInterfaceMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerInterfaceMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerInterfaceMockInfoExpectation{}
	}

	mmInfo.defaultExpectation.params = &LoggerInterfaceMockInfoParams{msg, arg, val}
	for _, e := range mmInfo.expectations {
		if minimock.Equal(e.params, mmInfo.defaultExpectation.params) {
			mmInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfo.defaultExpectation.params)
		}
	}

	return mmInfo
}

// Inspect accepts an inspector function that has same arguments as the LoggerInterface.Info
func (mmInfo *mLoggerInterfaceMockInfo) Inspect(f func(msg string, arg string, val string)) *mLoggerInterfaceMockInfo {
	if mmInfo.mock.inspectFuncInfo != nil {
		mmInfo.mock.t.Fatalf("Inspect function is already set for LoggerInterfaceMock.Info")
	}

	mmInfo.mock.inspectFuncInfo = f

	return mmInfo
}

// Return sets up results that will be returned by LoggerInterface.Info
func (mmInfo *mLoggerInterfaceMockInfo) Return() *LoggerInterfaceMock {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerInterfaceMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerInterfaceMockInfoExpectation{mock: mmInfo.mock}
	}

	return mmInfo.mock
}

//Set uses given function f to mock the LoggerInterface.Info method
func (mmInfo *mLoggerInterfaceMockInfo) Set(f func(msg string, arg string, val string)) *LoggerInterfaceMock {
	if mmInfo.defaultExpectation != nil {
		mmInfo.mock.t.Fatalf("Default expectation is already set for the LoggerInterface.Info method")
	}

	if len(mmInfo.expectations) > 0 {
		mmInfo.mock.t.Fatalf("Some expectations are already set for the LoggerInterface.Info method")
	}

	mmInfo.mock.funcInfo = f
	return mmInfo.mock
}

// Info implements logger.LoggerInterface
func (mmInfo *LoggerInterfaceMock) Info(msg string, arg string, val string) {
	mm_atomic.AddUint64(&mmInfo.beforeInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmInfo.afterInfoCounter, 1)

	if mmInfo.inspectFuncInfo != nil {
		mmInfo.inspectFuncInfo(msg, arg, val)
	}

	mm_params := &LoggerInterfaceMockInfoParams{msg, arg, val}

	// Record call args
	mmInfo.InfoMock.mutex.Lock()
	mmInfo.InfoMock.callArgs = append(mmInfo.InfoMock.callArgs, mm_params)
	mmInfo.InfoMock.mutex.Unlock()

	for _, e := range mmInfo.InfoMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfo.InfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfo.InfoMock.defaultExpectation.Counter, 1)
		mm_want := mmInfo.InfoMock.defaultExpectation.params
		mm_got := LoggerInterfaceMockInfoParams{msg, arg, val}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfo.t.Errorf("LoggerInterfaceMock.Info got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfo.funcInfo != nil {
		mmInfo.funcInfo(msg, arg, val)
		return
	}
	mmInfo.t.Fatalf("Unexpected call to LoggerInterfaceMock.Info. %v %v %v", msg, arg, val)

}

// InfoAfterCounter returns a count of finished LoggerInterfaceMock.Info invocations
func (mmInfo *LoggerInterfaceMock) InfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.afterInfoCounter)
}

// InfoBeforeCounter returns a count of LoggerInterfaceMock.Info invocations
func (mmInfo *LoggerInterfaceMock) InfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.beforeInfoCounter)
}

// Calls returns a list of arguments used in each call to LoggerInterfaceMock.Info.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfo *mLoggerInterfaceMockInfo) Calls() []*LoggerInterfaceMockInfoParams {
	mmInfo.mutex.RLock()

	argCopy := make([]*LoggerInterfaceMockInfoParams, len(mmInfo.callArgs))
	copy(argCopy, mmInfo.callArgs)

	mmInfo.mutex.RUnlock()

	return argCopy
}

// MinimockInfoDone returns true if the count of the Info invocations corresponds
// the number of defined expectations
func (m *LoggerInterfaceMock) MinimockInfoDone() bool {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockInfoInspect logs each unmet expectation
func (m *LoggerInterfaceMock) MinimockInfoInspect() {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerInterfaceMock.Info with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		if m.InfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerInterfaceMock.Info")
		} else {
			m.t.Errorf("Expected call to LoggerInterfaceMock.Info with params: %#v", *m.InfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		m.t.Error("Expected call to LoggerInterfaceMock.Info")
	}
}

type mLoggerInterfaceMockRelease struct {
	mock               *LoggerInterfaceMock
	defaultExpectation *LoggerInterfaceMockReleaseExpectation
	expectations       []*LoggerInterfaceMockReleaseExpectation
}

// LoggerInterfaceMockReleaseExpectation specifies expectation struct of the LoggerInterface.Release
type LoggerInterfaceMockReleaseExpectation struct {
	mock *LoggerInterfaceMock

	Counter uint64
}

// Expect sets up expected params for LoggerInterface.Release
func (mmRelease *mLoggerInterfaceMockRelease) Expect() *mLoggerInterfaceMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("LoggerInterfaceMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &LoggerInterfaceMockReleaseExpectation{}
	}

	return mmRelease
}

// Inspect accepts an inspector function that has same arguments as the LoggerInterface.Release
func (mmRelease *mLoggerInterfaceMockRelease) Inspect(f func()) *mLoggerInterfaceMockRelease {
	if mmRelease.mock.inspectFuncRelease != nil {
		mmRelease.mock.t.Fatalf("Inspect function is already set for LoggerInterfaceMock.Release")
	}

	mmRelease.mock.inspectFuncRelease = f

	return mmRelease
}

// Return sets up results that will be returned by LoggerInterface.Release
func (mmRelease *mLoggerInterfaceMockRelease) Return() *LoggerInterfaceMock {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("LoggerInterfaceMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &LoggerInterfaceMockReleaseExpectation{mock: mmRelease.mock}
	}

	return mmRelease.mock
}

//Set uses given function f to mock the LoggerInterface.Release method
func (mmRelease *mLoggerInterfaceMockRelease) Set(f func()) *LoggerInterfaceMock {
	if mmRelease.defaultExpectation != nil {
		mmRelease.mock.t.Fatalf("Default expectation is already set for the LoggerInterface.Release method")
	}

	if len(mmRelease.expectations) > 0 {
		mmRelease.mock.t.Fatalf("Some expectations are already set for the LoggerInterface.Release method")
	}

	mmRelease.mock.funcRelease = f
	return mmRelease.mock
}

// Release implements logger.LoggerInterface
func (mmRelease *LoggerInterfaceMock) Release() {
	mm_atomic.AddUint64(&mmRelease.beforeReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmRelease.afterReleaseCounter, 1)

	if mmRelease.inspectFuncRelease != nil {
		mmRelease.inspectFuncRelease()
	}

	if mmRelease.ReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRelease.ReleaseMock.defaultExpectation.Counter, 1)

		return

	}
	if mmRelease.funcRelease != nil {
		mmRelease.funcRelease()
		return
	}
	mmRelease.t.Fatalf("Unexpected call to LoggerInterfaceMock.Release.")

}

// ReleaseAfterCounter returns a count of finished LoggerInterfaceMock.Release invocations
func (mmRelease *LoggerInterfaceMock) ReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.afterReleaseCounter)
}

// ReleaseBeforeCounter returns a count of LoggerInterfaceMock.Release invocations
func (mmRelease *LoggerInterfaceMock) ReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.beforeReleaseCounter)
}

// MinimockReleaseDone returns true if the count of the Release invocations corresponds
// the number of defined expectations
func (m *LoggerInterfaceMock) MinimockReleaseDone() bool {
	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRelease != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		return false
	}
	return true
}

// MinimockReleaseInspect logs each unmet expectation
func (m *LoggerInterfaceMock) MinimockReleaseInspect() {
	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LoggerInterfaceMock.Release")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		m.t.Error("Expected call to LoggerInterfaceMock.Release")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRelease != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		m.t.Error("Expected call to LoggerInterfaceMock.Release")
	}
}

type mLoggerInterfaceMockWarn struct {
	mock               *LoggerInterfaceMock
	defaultExpectation *LoggerInterfaceMockWarnExpectation
	expectations       []*LoggerInterfaceMockWarnExpectation

	callArgs []*LoggerInterfaceMockWarnParams
	mutex    sync.RWMutex
}

// LoggerInterfaceMockWarnExpectation specifies expectation struct of the LoggerInterface.Warn
type LoggerInterfaceMockWarnExpectation struct {
	mock   *LoggerInterfaceMock
	params *LoggerInterfaceMockWarnParams

	Counter uint64
}

// LoggerInterfaceMockWarnParams contains parameters of the LoggerInterface.Warn
type LoggerInterfaceMockWarnParams struct {
	msg string
	arg string
	val string
}

// Expect sets up expected params for LoggerInterface.Warn
func (mmWarn *mLoggerInterfaceMockWarn) Expect(msg string, arg string, val string) *mLoggerInterfaceMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerInterfaceMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerInterfaceMockWarnExpectation{}
	}

	mmWarn.defaultExpectation.params = &LoggerInterfaceMockWarnParams{msg, arg, val}
	for _, e := range mmWarn.expectations {
		if minimock.Equal(e.params, mmWarn.defaultExpectation.params) {
			mmWarn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarn.defaultExpectation.params)
		}
	}

	return mmWarn
}

// Inspect accepts an inspector function that has same arguments as the LoggerInterface.Warn
func (mmWarn *mLoggerInterfaceMockWarn) Inspect(f func(msg string, arg string, val string)) *mLoggerInterfaceMockWarn {
	if mmWarn.mock.inspectFuncWarn != nil {
		mmWarn.mock.t.Fatalf("Inspect function is already set for LoggerInterfaceMock.Warn")
	}

	mmWarn.mock.inspectFuncWarn = f

	return mmWarn
}

// Return sets up results that will be returned by LoggerInterface.Warn
func (mmWarn *mLoggerInterfaceMockWarn) Return() *LoggerInterfaceMock {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerInterfaceMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerInterfaceMockWarnExpectation{mock: mmWarn.mock}
	}

	return mmWarn.mock
}

//Set uses given function f to mock the LoggerInterface.Warn method
func (mmWarn *mLoggerInterfaceMockWarn) Set(f func(msg string, arg string, val string)) *LoggerInterfaceMock {
	if mmWarn.defaultExpectation != nil {
		mmWarn.mock.t.Fatalf("Default expectation is already set for the LoggerInterface.Warn method")
	}

	if len(mmWarn.expectations) > 0 {
		mmWarn.mock.t.Fatalf("Some expectations are already set for the LoggerInterface.Warn method")
	}

	mmWarn.mock.funcWarn = f
	return mmWarn.mock
}

// Warn implements logger.LoggerInterface
func (mmWarn *LoggerInterfaceMock) Warn(msg string, arg string, val string) {
	mm_atomic.AddUint64(&mmWarn.beforeWarnCounter, 1)
	defer mm_atomic.AddUint64(&mmWarn.afterWarnCounter, 1)

	if mmWarn.inspectFuncWarn != nil {
		mmWarn.inspectFuncWarn(msg, arg, val)
	}

	mm_params := &LoggerInterfaceMockWarnParams{msg, arg, val}

	// Record call args
	mmWarn.WarnMock.mutex.Lock()
	mmWarn.WarnMock.callArgs = append(mmWarn.WarnMock.callArgs, mm_params)
	mmWarn.WarnMock.mutex.Unlock()

	for _, e := range mmWarn.WarnMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarn.WarnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarn.WarnMock.defaultExpectation.Counter, 1)
		mm_want := mmWarn.WarnMock.defaultExpectation.params
		mm_got := LoggerInterfaceMockWarnParams{msg, arg, val}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarn.t.Errorf("LoggerInterfaceMock.Warn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarn.funcWarn != nil {
		mmWarn.funcWarn(msg, arg, val)
		return
	}
	mmWarn.t.Fatalf("Unexpected call to LoggerInterfaceMock.Warn. %v %v %v", msg, arg, val)

}

// WarnAfterCounter returns a count of finished LoggerInterfaceMock.Warn invocations
func (mmWarn *LoggerInterfaceMock) WarnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.afterWarnCounter)
}

// WarnBeforeCounter returns a count of LoggerInterfaceMock.Warn invocations
func (mmWarn *LoggerInterfaceMock) WarnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.beforeWarnCounter)
}

// Calls returns a list of arguments used in each call to LoggerInterfaceMock.Warn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarn *mLoggerInterfaceMockWarn) Calls() []*LoggerInterfaceMockWarnParams {
	mmWarn.mutex.RLock()

	argCopy := make([]*LoggerInterfaceMockWarnParams, len(mmWarn.callArgs))
	copy(argCopy, mmWarn.callArgs)

	mmWarn.mutex.RUnlock()

	return argCopy
}

// MinimockWarnDone returns true if the count of the Warn invocations corresponds
// the number of defined expectations
func (m *LoggerInterfaceMock) MinimockWarnDone() bool {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		return false
	}
	return true
}

// MinimockWarnInspect logs each unmet expectation
func (m *LoggerInterfaceMock) MinimockWarnInspect() {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerInterfaceMock.Warn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		if m.WarnMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerInterfaceMock.Warn")
		} else {
			m.t.Errorf("Expected call to LoggerInterfaceMock.Warn with params: %#v", *m.WarnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		m.t.Error("Expected call to LoggerInterfaceMock.Warn")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoggerInterfaceMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDebugInspect()

		m.MinimockErrorInspect()

		m.MinimockFatalInspect()

		m.MinimockInfoInspect()

		m.MinimockReleaseInspect()

		m.MinimockWarnInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoggerInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoggerInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDebugDone() &&
		m.MinimockErrorDone() &&
		m.MinimockFatalDone() &&
		m.MinimockInfoDone() &&
		m.MinimockReleaseDone() &&
		m.MinimockWarnDone()
}
